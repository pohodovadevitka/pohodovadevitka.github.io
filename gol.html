<!DOCTYPE html>
<html>
<head>
    <title>Game of life</title>
    <style>
        #board {
            border: 1px solid silver;
            float: left;
            margin-top: 1em;
        }
        #board > div {
            width: 10px;
            height: 10px;
            float: left;
        }
        #board > div.br {
            clear: both;
        }
        #board > div:hover {
            background-color: silver;
        }
        #board > div.alive {
            background-color: black;
        }
        label, input {
            text-align: right;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div>
        <label>
            Velikost:
            <input type="number" min="5" max="100" step="5" value="100" size="3" id="size">
        </label>
        <label>
            Trvání:
            <input type="number" min="0" max="1000" step="10" value="10" id="duration">
        </label>
        <input type="button" value="Play" id="pause">
        <input type="button" value="Vymazat" id="clear">
    </div>
    <div>
        <div id="board"></div>
    </div>
    <script>
class Board {
    constructor(parent) {
        this._parent = parent;
        this._elements = [];
        this._size = 0;
    }

    setSize(size) {
        if (this._size !== size) {
            this._size = size;
            this._reset();
        }
    }

    _reset() {
        this._parent.innerHTML = "";
        this._elements = [];

        for (let y = 0; y < this._size; y++) {
            this._elements[y] = [];
            for (let x = 0; x < this._size; x++) {
                const e = this._elements[y][x] = document.createElement("div");
                e.dataset.x = x;
                e.dataset.y = y;
                if (x === 0) {
                    e.classList.add("br");
                }
                this._parent.appendChild(e);
            }
        }
    }

    render(cells) {
        for (let y = 0; y < this._size; y++) {
            for (let x = 0; x < this._size; x++) {
                this.renderCell(x, y, cells[y][x]);
            }
        }
    }

    renderCell(x, y, alive) {
        if (alive) {
            this._elements[y][x].classList.add("alive");
        } else {
            this._elements[y][x].classList.remove("alive");
        }
    }

    onClick(f) {
        this._parent.addEventListener("click", (e) => {
            if ("x" in e.target.dataset && "y" in e.target.dataset) {
                const x = parseInt(e.target.dataset.x, 10);
                const y = parseInt(e.target.dataset.y, 10);
                f(x, y);
            }
        });
    }
}

function countOfLivingNeighbors(x, y, cells) {
    return ~~(cells?.[y - 1]?.[x - 1])
         + ~~(cells?.[y - 1]?.[x])
         + ~~(cells?.[y - 1]?.[x + 1])
         + ~~(cells?.[y]?.[x - 1])
         + ~~(cells?.[y]?.[x + 1])
         + ~~(cells?.[y + 1]?.[x - 1])
         + ~~(cells?.[y + 1]?.[x])
         + ~~(cells?.[y + 1]?.[x + 1]);
}

function breed(x, y, cells) {
    const count = countOfLivingNeighbors(x, y, cells);
    const alive = cells[y][x];
    return (alive && (count === 2 || count === 3))
        || (!alive && count === 3);
}

function nextGenenration(cells) {
    return cells.map((row, y) => row.map((_, x) => breed(x, y, cells)))
}

class Game {
    constructor(board, size, duration) {
        this._board = board;
        this.size = size;
        this.duration = duration;
        this.paused = true;
        this._cells = [];
        this._selected = [];
        this._timer = null;
    }

    selectCell(x, y) {
        this._selected.push({x, y});
        this._board.renderCell(x, y, true);
    }

    run() {
        if (this._timer) {
            clearInterval(this._timer);
        }
        this._cells = Array(this.size).fill(null).map(() => Array(this.size).fill(false))
        this._board.setSize(this.size);
        this._board.render(this._cells);

        this._timer = setInterval(() => {
            if (this.paused) {
                return;
            }

            for (let {x, y} of this._selected) {
                this._cells[y][x] = true;
            }
            this._selected = [];

            this._cells = nextGenenration(this._cells);
            this._board.render(this._cells);
        }, this.duration);
    }
}

const elements = {
    board: document.getElementById("board"),
    clear: document.getElementById("clear"),
    duration: document.getElementById("duration"),
    pause: document.getElementById("pause"),
    size: document.getElementById("size"),
};

const board = new Board(elements.board);
const game = new Game(board, 100, 10);

board.setSize(game.size);
elements.size.value = game.size;
elements.duration.value = game.duration;

board.onClick((x, y) => game.selectCell(x, y));

elements.pause.addEventListener("click", (e) => {
    game.paused = !game.paused;
    e.target.value = game.paused ? "Play" : "Pause"
});

elements.clear.addEventListener("click", (e) => {
    game.run();
});

elements.duration.addEventListener("change", (e) => {
    game.duration = parseInt(e.target.value, 10);
});

elements.size.addEventListener("change", (e) => {
    game.size = parseInt(e.target.value, 10);
    game.run();
});

game.run();

    </script>
</body>
</html>
